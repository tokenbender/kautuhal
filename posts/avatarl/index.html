<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>avatarl: training language models from scratch with pure reinforcement learning - tokenbender</title>
    <meta name="description" content="replacing cross-entropy pretraining with a principled rl objective using expert-consensus rewards over active tokens">
    <meta name="robots" content="index,follow,max-image-preview:large">
    <meta property="og:type" content="article">
    <meta property="og:site_name" content="tokenbender">
    <meta property="og:title" content="avatarl: training language models from scratch with pure reinforcement learning">
    <meta property="og:description" content="replacing cross-entropy pretraining with a principled rl objective using expert-consensus rewards over active tokens">
    <meta property="og:url" content="https://tokenbender.com/posts/avatarl/">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="avatarl: training language models from scratch with pure reinforcement learning">
    <meta name="twitter:description" content="replacing cross-entropy pretraining with a principled rl objective using expert-consensus rewards over active tokens">
    <link rel="canonical" href="https://tokenbender.com/posts/avatarl/">
    <script>(function () {
    const storageKey = 'tokenbender-theme';
    const root = document.documentElement;
    let storedTheme = null;
    try {
        storedTheme = window.localStorage.getItem(storageKey);
    } catch (error) {}

    if (storedTheme === 'light' || storedTheme === 'dark') {
        root.setAttribute('data-theme', storedTheme);
        return;
    }

    const prefersLight = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches;
    root.setAttribute('data-theme', prefersLight ? 'light' : 'dark');
})();</script>
    <link rel="stylesheet" href="/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css">
    <script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","headline":"avatarl: training language models from scratch with pure reinforcement learning","description":"replacing cross-entropy pretraining with a principled rl objective using expert-consensus rewards over active tokens","author":{"@type":"Person","name":"tokenbender"},"publisher":{"@type":"Person","name":"tokenbender"},"url":"https://tokenbender.com/posts/avatarl/","mainEntityOfPage":{"@type":"WebPage","@id":"https://tokenbender.com/posts/avatarl/"},"datePublished":"2025-08-09T00:00:00.000Z","dateModified":"2025-08-09T00:00:00.000Z"}</script>
</head>
<body>
    <header>
        <nav>
            <div class="nav-container">
                <a href="/index.html" class="logo">tokenbender</a>
                <div class="nav-links">
                    <a href="/posts/">archive</a>
                    <a href="https://tokenbender.com/posts/avatarl/">post</a>
                    <button type="button" class="theme-toggle" data-theme-toggle aria-label="switch theme">light</button>
                </div>
            </div>
        </nav>
    </header>

    <main class="container">
        <article class="post-content" id="post-content">
            <div class="post-date">August 9, 2025</div>
            <h1>avatarl: training language models from scratch with pure reinforcement learning</h1>
            <blockquote>
<p>&quot;if you know the way broadly you will see it in all things&quot; — Miyamoto Musashi</p>
</blockquote>
<h2>abstract</h2>
<p>standard language model pre-training relies on a cross-entropy objective, which rigidly teaches the model that only a single token is the correct continuation for a given context. this is a fundamentally incomplete representation of language, where multiple continuations are often plausible.</p>
<p>avatarl addresses this by replacing the traditional cross-entropy objective with a sophisticated <strong>reinforcement learning (rl) framework</strong>. during the pre-training phase, a player model learns from a <strong>continuous reward signal</strong> derived from a pre-trained critic and ground-truth reality. this allows the player to learn a rich, distributional understanding of language, rewarding it for predicting tokens that are not just the single &#39;correct&#39; answer but are also plausible alternatives, as judged by the critic. this approach represents a more principled pre-training objective, designed to create models with a deeper and more nuanced understanding of language from the very beginning [1].</p>
<hr>
<h2>understanding avatarl</h2>
<p>imagine you&#39;re teaching a child (the player model) how to play a piano. </p>
<p><strong>traditional pretraining</strong>: the piano student sits with a strict teacher who slaps their hand every time they hit the wrong key. &quot;No! Only C# here! Never D!&quot; The student memorizes thousands of songs note-by-note and is terrified of mistakes. this creates a technically perfect but robotic player who can only reproduce what they&#39;ve memorized.</p>
<p><strong>avatarl&#39;s rl approach</strong>: the student plays in a jazz club with an experienced critic watching. instead of punishment, they get applause. loud cheers for perfect notes, moderate clapping for harmonious alternatives, polite claps for creative attempts. the critic (a seasoned jazz pianist) whispers suggestions: &quot;try a B♭ there, it creates tension&quot; the student learns not just what&#39;s &quot;correct&quot; but what&#39;s musically meaningful.</p>
<p>in rl terms:</p>
<ul>
<li><strong>state</strong>: the musical context (previous notes played)</li>
<li><strong>action</strong>: choosing the next note</li>
<li><strong>reward signal</strong>: continuous applause (0 to 1)</li>
<li><strong>policy</strong>: the student&#39;s evolving musical intuition</li>
<li><strong>critic</strong>: provides expertise without dictating every note</li>
</ul>
<p>the best part starts when the student starts improvising - they play their own ideas (student top-k), consider the critic&#39;s suggestions (critic top-k), while keeping the original melody in mind (ground truth). over time, they develop their own style while respecting musical theory. this is reinforcement learning i.e. learning through rewards rather than rigid correction, discovering patterns through exploration rather than memorization. </p>
<h3>standard pretraining =&gt; one-hot encoded lottery</h3>
<p>there is RL everywhere for those with the eyes to see.
this is your traditional pretraining but you can also think of it as REINFORCE with binary rewards.</p>
<pre><code class="language-ascii">   standard cross-entropy loss
   
   context: &quot;the cat...&quot;
   
   [sat] [jumped] [ran] [slept]
     ↓      ↓       ↓      ↓
    WIN    LOSE    LOSE   LOSE
   
   payout rules:
   - hit the exact word from training data = win $1
   - hit anything else = lose
   
</code></pre>
<h3>avatarl =&gt; progressive reward lottery</h3>
<p>we can reimagine the same problem as a progressive reward lottery.</p>
<pre><code class="language-ascii">   avatarl&#39;s continuous rewards
   
   context: &quot;the cat...&quot;
   
   [sat] [jumped] [ran] [slept]
     ↓      ↓       ↓      ↓
    HIGH    MED     LOW    TINY
   
   payout rules (from expert consensus):
   - ground truth (sat) = $82
   - critic&#39;s favorites = $10-45  
   - plausible alternatives = $1-9
   - noise = nothing
   
</code></pre>
<hr>
<h2>the problems with RL in pre-training language modeling</h2>
<p>now how do we design this around some of the challenges we face in RL?</p>
<h3>intuition</h3>
<p>let us look at how we teach the model traditionally. standard pretraining with cross-entropy loss for predicting the next token. this can be visualised as a special case of REINFORCE algorithm where only the gold token gets reward 1.0 and all others get 0 [3]. so we can at least create a binary reward where gold token gets 1 and all others get 0. the challenge of framing pretraining as an rl problem isn&#39;t hard however there are a few concerning points.</p>
<pre><code class="language-ascii">   broadly RL looks like this:

   step 1: sample action (probability of each action - inverse of size of action space)
   step 2: run rollout (reward for each action)
   step 3: update policy (gradient descent)
</code></pre>
<p>the first problem is that <strong>the action space is too large for a language model</strong> on token level because the entire vocab size is ~50k. and one of the biggest reasons we do pretraining before RL is to make sure the most probable actions are the ones that are most likely to be correct. so if we expect chances of correct token to be present in top 64 choices, we can rollout 64 times and get the reward for each action. however, without pretraining, the probability of next token being correct is random chance - 1/50k i.e. 0.002% so if you do rollouts you&#39;d get 0.002% * 64 = 0.128% chance of getting the correct token. huge number of rollouts per step and such low reward signal makes it computationally extremely expensive to train a model using pure RL.</p>
<p>the second problem is that the <strong>win condition is not absolutely clear</strong>. traditional RL in games is something with deterministic win or loss. each action being rewarded or punished enforces the model to learn the correct action over a limited space. however, in language modeling, the win condition is not clear, given the context the right way to predict the next token could vary a lot. and this creates a challenge that if you wanted to have a clear win condition or if you wanted to have a smooth probabilistic range of partial reward, then that becomes extremely hard with large language models. the model is not trying to win a game, it is trying to minimise the loss over predicting the next token. and the bigger the context is, the more variation can be expected in what could be the correct next token. </p>
<p>at its core, avatarl reframes language model pre-training as a reinforcement learning problem. the student model is an rl agent that learns to make decisions (predicting the next token) in an environment (the text sequence so far). this approach aligns with the reincarnated rl paradigm [8], where we reuse prior computational work (the pre-trained critic) rather than starting from scratch. </p>
<p>as a solution to first problem, we can use a smaller action space. but reducing the action space arbitrarily does nothing. we apply something which is called <strong>active token filtering</strong> to eliminate the inconsequential tokens. we use the critic model to share its knowledge of the world (critic top k) and the student does the same (student top k). we combine this with the ground truth to create a subset of actions that are most likely to be correct (max <code>2*k + 1</code> action space). the student learns from the highly likely actions. for sampling-related context in language models, see top-k and nucleus (top-p) sampling analyses [5].</p>
<p>for the second problem, we need something to act as a mechanism to provide a smooth reward range which can provide appropriately reward the actions. simply relying on just gold token keeps the reward signal sparse and relying on just critic distribution either becomes distillation if the critic is a bigger teacher model. it also puts a cap on the value from the reward signal, the student model does not derive value after reaching similar level as the critic. we need an option to leverage the reward signal from the critic and the student. and ideally create a method which teaches the model richer distribution than just one-hot encoding and also does not remain capped on the value from the critic reward.</p>
<p>the entire process can be visualized as a simple loop:</p>
<pre><code class="language-ascii">+-------------------+      +-------------------+
|   state s_t       | ---&gt; | student policy    |
|  (context tokens) |      | π_θ(s_t) → logits |
+-------------------+      +-------------------+
            |                         |
            |         +---------------+---------------+
            |         |                               |
            v         v                               v
     +-----------+  +-----------+               +-------------+
     | top-k_s   |  | top-k_c   |               | gold token  |
     | (student) |  | (critic)  |               | a*_t        |
     +-----------+  +-----------+               +-------------+
            \            |   |                       /
             \           |   |                      /
              \          v   v                     /
               +----------------------------------+
               | filtered actions A_t             |
               | (≤ 2k + 1, deduped)             |
               +----------------------------------+
                            |
                            v
               +----------------------------------+
               | reward model (expert consensus):|
               | reality + critic (blend);       |
               | active-token smoothing          |
               +----------------------------------+
                            |
                            v
               +----------------------------------+
               | r_i over A_t: renorm on A_t      |
               | reward only above-mean; clamp max|
               +----------------------------------+
                            |
                            v
               +----------------------------------+
               | REINFORCE update                 |
               | L = -Σ_i r_i · log π_θ(a_i|s_t) |
               | + entropy bonus                  |
               +----------------------------------+
                            |
                            v
               +----------------------------------+
               | update θ; pick a_t ∈ A_t         |
               | append to context → s_{t+1}      |
               +----------------------------------+
                            |
                            v
                          (loop)
</code></pre>
<p>notation used above: <code>s_t</code> = context at time t (tokens so far); <code>a*_t</code> = ground-truth next token; <code>A_t</code> = student top-k ∪ critic top-k ∪ <code>{a*_t}</code> (deduped, ≤ <code>2k+1</code>); <code>π_θ(a|s_t)</code> = student policy over tokens; <code>r_i</code> = reward for action <code>a_i ∈ A_t</code>.</p>
<p>in <strong>avatarl reward mechanism</strong>. instead of a sparse <code>+1</code> for the correct token and <code>0</code> for all others, we construct an &quot;ideal&quot; reward model at each step that provides a dense, continuous reward signal for any potential action. this reward model is an <strong>expert consensus</strong>.</p>
<h2>how to combine the reality and the critic?</h2>
<h3>the expert consensus problem → active-token smoothing</h3>
<p>there’s a subtle problem with expert consensus if we’re not careful. if the reality expert
is one-hot, rewards become ultra-sparse and the student gets almost no exploration signal.
if we lean only on the critic, we cap the student at the critic’s quality and inherit its
biases. if we smooth over the full vocabulary, we sprinkle reward on implausible junk and
dilute the gradient.</p>
<p>the rationale is simple: give plausible alternatives a fair chance without rewarding noise.
most of the probability should remain on what actually happened (the ground truth), but a
small ε should be shared only among tokens that are likely in this context. this keeps
exploration focused, plays nicely with the critic’s judgement, and stabilizes the
REINFORCE update.</p>
<p>the process inside expert consensus looks like this:</p>
<pre><code class="language-ascii">active-token smoothing within expert consensus (reality + critic)

context s_t
   |
student top-k_s     critic top-k_c     gold a*
        \             |      |            /
         \            |      |           /
          +--------------------------------------+
          | A_t = dedup(top-k_s ∪ top-k_c ∪ {a*}) |
          | (≤ 2k + 1 tokens)                      |
          +--------------------------------------+
                      |
                      v
reality distribution over A_t:
- a* gets 1 - ε
- others in A_t share ε / (|A_t| - 1)
- outside A_t gets 0
                      |
                      v
critic distribution (restricted to A_t)
                      |
                      v
expert consensus (blend reality + critic)
- renormalize only on A_t
- above-mean mask + clamp
                      |
                      v
final rewards r_i over A_t → used by REINFORCE
</code></pre>
<h4>1. the ground truth expert</h4>
<p>we need to create a reward signal for the ground truth token. we can do this by using a one-hot encoding over the full vocabulary. however, this is not a good signal for the model to learn from. we need to create a reward signal that is more informative. we can do this by using a label smoothing technique.</p>
<pre><code class="language-ascii">
   before: one-hot over full vocab       after: active-token label smoothing (A_t only)
   ┌──────────────────────────────┐      ┌──────────────────────────────────────────────┐
   │ ground truth a* = 100%      │      │ A_t = dedup(top-k_s ∪ top-k_c ∪ {a*})       │
   │ everything else = 0%        │  →   │ |A_t| ≤ 2k+1 (≈ 33 when k=16)               │
   └──────────────────────────────┘      │                                              │
                                         │ p_reality(a*) = 1 - ε                        │
                                         │ p_reality(a ≠ a*, a ∈ A_t) = ε/(|A_t|-1)     │
                                         │ p_reality(a ∉ A_t) = 0                       │
                                         │                                              │
                                         │ example: k=16, ε=0.10, |A_t|=33               │
                                         │   a* = 90.000%                                │
                                         │   each other in A_t ≈ 0.3125%                 │
                                         └──────────────────────────────────────────────┘

   &quot;we already have the ground truth, but we’ll share a small ε only among the ~2*k + 1 tokens
    that actually matter in this context — nothing for the rest.&quot;
</code></pre>
<h4>2. using the critic expert as the calibrated judge</h4>
<p>to create plausible alternatives, we can use the critic model. the critic model is a pre-trained model that has been trained to predict the next token. we can use the critic model to create a reward signal for the purpose.</p>
<pre><code class="language-ascii">   
   ┌─────────────────────┐
   │ based on model priors:   │
   │ &quot;sat&quot; = 60%            │
   │ &quot;slept&quot; = 30%          │
   │ &quot;jumped&quot; = 8%          │
   │ &quot;flew&quot; = 2%            │
   └─────────────────────┘
   
   &quot;many things could work here; we score them consistently.&quot;
</code></pre>
<h3>the expert consensus</h3>
<p>we can combine their reward signals using a <strong>weighted geometric mean</strong>:</p>
<pre><code class="language-ascii">   
   reality (70% weight)         critic (30% weight)
          \                          /
           \    geometric mean      /
            \    p^0.7 × p^0.3     /
             \                    /
              [combined wisdom]
                      |
                      v
            ┌─────────────────┐
            │ final rewards:   │
            │ &quot;sat&quot; = 82%     │  &lt;-- ground truth still wins
            │ &quot;slept&quot; = 15%   │  &lt;-- but critic&#39;s ideas get credit
            │ &quot;jumped&quot; = 2%   │  &lt;-- even small ideas matter
            │ &quot;flew&quot; = 0.1%   │  &lt;-- tiny but non-zero to promote exploration
            └─────────────────┘
</code></pre>
<pre><code class="language-ascii">   the formula visualized
   
   reality expert says:          critic expert says:
   ┌──────────────┐             ┌──────────────┐
   │ &quot;sat&quot; = 0.9  │             │ &quot;sat&quot; = 0.6  │
   │ others = 0.1 │             │ &quot;slept&quot; = 0.3│
   └──────────────┘             │ &quot;jumped&quot;= 0.08│
          ↓                      └──────────────┘
          ↓ power of 0.7                ↓ power of 0.3
          ↓                             ↓
      0.9^0.7 = 0.93            0.6^0.3 = 0.86
          ↓                             ↓
          └─────────────┬───────────────┘
                        │
                    multiply
                        │
                   0.93 × 0.86
                        │
                     = 0.80
                        │
                  (normalize all)
                        │
                        ↓
              ┌─────────────────┐
              │ &quot;sat&quot; = 82%     │  &lt;-- ideal reward
              │ &quot;slept&quot; = 15%   │  &lt;-- decent reward
              │ &quot;jumped&quot; = 2%   │  &lt;-- try again
              └─────────────────┘
                        ↓
                 scale by 100
                        ↓
              rewards then sparsified (above-mean),
              and proportionally capped per position (≤ 1.5)
</code></pre>
<p><strong>intuition</strong>: for a token to receive higher rewards, both experts must agree. the smoothed reality expert ensures the ground truth is strongly preferred without completely vetoing alternatives, while the critic expert provides a smooth gradient of preferences for all plausible tokens. the resulting probabilities serve directly as positive rewards.</p>
<h3>the mathematical model of the reward signal</h3>
<p>a key insight of avatarl is that we do not create a reward for a <em>single</em> action the student takes. instead, we first construct a <strong>dense reward landscape</strong> for <em>active filtered tokens</em>, and then we evaluate the student&#39;s policy against this landscape.</p>
<p><strong>1. defining the experts mathematically</strong></p>
<p>let <code>a</code> be a potential action (a token) and <code>a*</code> be the ground-truth token from the dataset.</p>
<ul>
<li><p><strong>the groundtruth expert, <code>p_reality(a | s)</code></strong>: this expert strongly prefers the ground-truth token <code>a*</code> but uses <strong>active token label smoothing</strong> to maintain a continuous distribution.</p>
<ul>
<li><code>p_reality(a | s) = 1 - ε</code> if <code>a = a*</code> (where <code>ε = 0.1</code>)</li>
<li><code>p_reality(a | s) = ε / (num_active - 1)</code> if <code>a ∈ active_tokens</code> and <code>a ≠ a*</code></li>
<li><code>p_reality(a | s) = 0</code> if <code>a ∉ active_tokens</code> (i.e. not in the active filtered tokens)</li>
</ul>
<p>where <code>active_tokens</code> = student&#39;s top-k ∪ critic&#39;s top-k ∪ {ground truth} (typically ≤32 tokens after deduplication)</p>
<p>this gives 90% probability to the ground truth and distributes 10% <strong>only across active tokens</strong> rather than the entire vocabulary. this concentrates the exploration signal on relevant alternatives instead of wasting it on 50,000+ irrelevant tokens.</p>
</li>
<li><p><strong>the critic expert, <code>p_critic(a | s)</code></strong>: the critic model&#39;s probability distribution over the vocabulary.</p>
<ul>
<li><code>p_critic(a | s) = softmax(critic_logits)</code></li>
</ul>
</li>
</ul>
<p><strong>2. the expert consensus formulation</strong></p>
<p>the ideal distribution, <code>p_ideal</code>, is the <strong>weighted geometric mean</strong> of the two expert distributions:</p>
<p><code>p_ref(a | s) ∝ [p_reality(a | s)]^w_r * [p_critic(a | s)]^w_m</code></p>
<p>here <code>w_r</code> (reality_weight) and <code>w_m</code> (mentor_weight) are the expert weights; defaults are 0.7 and 0.3 respectively. after normalization on the action set A, this gives us a proper probability distribution. the resulting <code>p_ref</code> serves as our <strong>positive reward signal</strong>—a vector over A containing the calibrated &quot;ideal&quot; probabilities (and thus rewards).</p>
<p><strong>3. evaluating the student&#39;s policy</strong></p>
<p>the student&#39;s policy, <code>π_student(a | s)</code>, is judged against this reward landscape. the policy gradient loss aims to move the student&#39;s distribution closer to the ideal one. the reinforce rule is <code>loss = -e_{a ~ π_student} [ r(a) ]</code>, where our reward <code>r(a) = p_ideal(a | s)</code>—we also add an entropy bonus <code>−β·H[π_θ(·|s)]</code> to encourage exploration, with <code>β = entropy_coefficient</code> (default 0.01) [2, 4]. in practice, stable policy-gradient updates often use PPO-style clipping and variance reduction such as GAE [6, 7].</p>
<h4>learning to calibrate the critic internally</h4>
<p>by including the student&#39;s top-k predictions in the action space, we create a self-reinforcement mechanism. not only the model learns to predict the ground truth, but also learns to calibrate the critic&#39;s predictions via its own top-k predictions.</p>
<p><strong>concurrent top-k evaluation</strong></p>
<p>instead of sampling actions and performing k sequential rollouts, avatarl concurrently evaluates the student&#39;s top-k, the critic&#39;s top-k, and the gold token — an efficient 2k+1 rollout-equivalent with guided exploration. specifically:</p>
<ul>
<li>we evaluate all actions in the expanded action space (~2k+1 tokens) simultaneously</li>
<li>each action gets its reward from the pre-computed expert consensus reward model</li>
<li>the student&#39;s entire probability distribution over these actions is updated via policy gradient</li>
</ul>
<pre><code class="language-ascii">   typical rl (k sequential rollouts):        avatarl (2k+1 rollout-equivalent, concurrent):
   
   sample action → run rollout (×k)       gather student top-k + critic top-k + gold
   sample action → run rollout            ↓
   sample action → run rollout            compute rewards for all selected actions
   ...repeat n times...                   ↓
   ↓                                      update policy on all actions
   average rewards                        simultaneously
   ↓                                      
   update policy                          one concurrent pass, guided exploration
   
   [slow &amp; high variance]                [fast &amp; low variance]
</code></pre>
<p>for efficient pretraining we avoid monte carlo sampling, and instead do <strong>exhaustive evaluation</strong> over the reduced action space.</p>
<p><strong>the mathematical truth</strong>:</p>
<pre><code class="language-python"># what avatarl doesn&#39;t do (sequential per-token rollouts):
for rollout in range(num_rollouts):  # no sequential rollouts per token
    action = sample_from_student()   # no stochastic rollout sampling at train time
    reward = run_episode(action)     # no multi-step episodes per token

# what avatarl actually does (k-rollout-equivalent, concurrent):
action_space = student_top_k ∪ critic_top_k ∪ ground_truth  # ~32 actions
rewards = consensus_model(action_space)  # pre-computed for all actions
loss = -sum(log_prob(action) * reward for action in action_space)  # update all at once
</code></pre>
<p><strong>per-prediction statistics</strong>:</p>
<ul>
<li><strong>rollout-equivalent</strong>: 2k+1 (student k + critic k + gold), evaluated concurrently</li>
<li><strong>actions evaluated</strong>: ~2k+1 (entire expanded action space)</li>
<li><strong>samples drawn</strong>: deterministic top-k selection (or top-p if enabled)</li>
<li><strong>reward computations</strong>: ~2k+1 (one per action in space)</li>
<li><strong>gradient updates</strong>: 1 (single policy gradient step)</li>
</ul>
<h2>results</h2>
<p>avatarl has been completely open sourced and researched in the open from day 1.
hence what you see are the earliest results after getting it to work.</p>
<p>we successfully validated the approach on a model in size range of 30M-250M parameters using avatarl. in each case, we used a critic model of size 30M parameters. around 2B tokens were used for training where the dataset used for this was <a href="https://huggingface.co/datasets/Skylion007/openwebtext">openwebtext</a>. </p>
<p>for the same param size, the avatarl trained model can reach similar cross entropy loss as a standard pretrained model.</p>
<p>avatarl also allows us to train the models for equivalent of 50-60B tokens on 2B tokens of data because of the dense reward signal.</p>
<p>this is how the training and validation curves look like for a 250M parameter model, validated every 500 steps.</p>
<h3>Training loss against combined distribution (2k+1)</h3>
<p><img src="posts/images/train_loss.png" alt="train_curves"></p>
<h3>Average Reward Progress</h3>
<p><img src="posts/images/avg_reward.png" alt="avg_reward"></p>
<h3>Cross-Entropy Loss</h3>
<p><img src="posts/images/ce_loss.png" alt="ce_loss"></p>
<h2>Samples</h2>
<h3>Generated Text Examples</h3>
<p><strong>Prompt:</strong> <em>&quot;The true meaning of life is often&quot;</em></p>
<hr>
<h4>Sample 1</h4>
<blockquote>
<p>The true meaning of life is often more complex than the actual cause, but we can think so much about each of them if we take into account the real and possible work that underlies an individual&#39;s character and personality.</p>
<p>When we do that, the very nature of our relations with other people takes us into their distinct forms and carries them far into their various circumstances. When a particular person is isolated from the &quot;ideal&quot; circle of people with whom we have worked – and others who are displaced from the</p>
</blockquote>
<h4>Sample 2</h4>
<blockquote>
<p>The true meaning of life is often an all-consuming exchange of goods — real commodities such as gold, services such as medicine, clothes and appliances — while also building up a certain personal meaning for all: this change helps us begin to transcend some material barrier to the search for meaning. Rather than content, though, we are simply noticing how the changes our material conditions are also creating.</p>
<p>Today, it&#39;s easy to underestimate how life can transition, if we didn&#39;t think so. Increasingly, health and education are more about</p>
</blockquote>
<h4>Sample 3</h4>
<blockquote>
<p>The true meaning of life is often put in terms of one&#39;s relationship with us. &quot;There is life of this for us as well,&quot; Mr. Adams says. &quot;For me, the meaning of life was precisely this.&quot;&lt;|endoftext|&gt;I was delighted to be offered the opportunity to see David Koretzner, one of my favorite television reporters who came into the world on such a busy note that I couldn&#39;t turn down this season&#39;s worth of tweets. Only four of them came</p>
</blockquote>
<h4>Sample 4</h4>
<blockquote>
<p>The true meaning of life is often malleable by the way they can change and change more naturally. If no matter how many lives they provide, life continues to be a process of change, and thus human life is often incomplete.</p>
<p>Is Life Any Better? If so, with all the information about human nature you would like to know about but have no knowledge about human nature, you might ask yourself why. It is not, in order to understand it, to practice and follow as best we can. The journey of your</p>
</blockquote>
<h4>Sample 5</h4>
<blockquote>
<p>The true meaning of life is often unknown: Death through illness has in fact brought death from one&#39;s own body into another.</p>
<p>Many now seem to see this in the light of a number of ways to die. But rather than focus on dying, we look to be on the look out for what death will bring to us. The notion of death is less cruel than life; death is more honest in each of its parts.</p>
<p>If the death of evil goes on all around us, our act of anger may well follow</p>
</blockquote>
<h4>Sample 6</h4>
<blockquote>
<p>The true meaning of life is often determined by circumstances and relationships. As such, personal freedom is a process unto itself and not something else.</p>
<p>This might seem like a completely false premise to be a &quot;mystical situation.&quot; However, the fact that every species has at least some sort of a right to life outside of its senses and attitudes shows it, quite literally, to be a person.</p>
<p>In other words, what the individual doesn&#39;t have is a right to life of their own free</p>
</blockquote>
<h4>Sample 7</h4>
<blockquote>
<p>The true meaning of life is often one of &#39;making up your mind&#39;.</p>
<p>It takes a lot of hard work and dedication every day for somebody to realize they are doing something amazing. After three years of planning and constant training it was almost clear that they had formed one of the best teams I&#39;ve ever been given.</p>
<p>My team worked hard. I had a pretty amazing package coming out of the kit room after sending home a huge package. Doing the team thing took time because there were times when there was absolutely nothing I</p>
</blockquote>
<h4>Sample 8</h4>
<blockquote>
<p>The true meaning of life is often about a certain general understanding of our existence and how we cope with our suffering. This is how people of a certain age, or a particular religious persuasion, perceive our existence.</p>
<p>We are now reminded that our understanding is limited in comparison to the scope of relationships within us. The way that we may assess ourselves under the ideal of our being the sum of our self-interest, we may do it to others and to oneself in order to make our bodies and identities relevant, but it will be</p>
</blockquote>
<h2>conclusion</h2>
<p>cross entropy based next token prediction pretraining as a bitter lesson pilled approach works. i have no issues against it. think of this as an enquiry into three points:</p>
<ol>
<li>people believing without strong base model rl doesn&#39;t work - so why can&#39;t the method used for avatarl (action space filtering and smoothing) work for them?</li>
<li>how different is the sample efficiency of learning for a model pretrained with rl?</li>
<li>is this something that can create models with more nuanced understanding of language and benefit from better calibration of top k?</li>
</ol>
<p>i originally started this as a cacklemaxxing project (idea which if it works would make me laugh). i am just doing it for satisfying questions in my head.</p>
<h2>future work</h2>
<p>this is a very early stage of the research.
i understand that to many trained eyes this feels incomplete.
i am also primarily a hacker and you may sniff it across my work.</p>
<p>the agi lab is understaffed (1 person - me) and we are planning to do the following:</p>
<ul>
<li>avatarl training objective as gradually sequence level training objective not just tokens</li>
<li>train for tool use and minimal world knowledge with pure RL - how small of a banger tool calling model can we get?</li>
</ul>
<p>if you wish to pick these ideas for yourself or if you wish to collaborate, let me know.
i would appreciate any support in the form of sponsorship, compute or research collaboration.</p>
<p>i would be sharing discussion on the approaches that i took but didn&#39;t succeed as well.</p>
<h2>acknowledgements</h2>
<p><a href="https://x.com/ChinmayKak">Chinmay Kak</a>, who discussed this with me on call and instantly started hacking the idea using GRPO. The skeleton code for the earliest version was written by him.</p>
<p><a href="https://x.com/twofifteenam">Telt</a> for the support and compute.</p>
<p><a href="https://x.com/ravithejads">Ravi Theja</a> for taking initiative on his own to put me in touch with @except_raised.</p>
<p>huge thanks to everyone who reposted, shared and got it the initial attention, i appreciate all of you.</p>
<p>modal cloud is awesome. it makes running experiments simple. no worrying about instance management or forgotten resources - it just works. it kinda suits my adhd hacker brain very well.</p>
<p>the infrastructure is solid too. cold starts that take just 5-6s time let me hack things out locally and simply trigger the job with a command.</p>
<h2>sponsorship</h2>
<p>this work was sponsored for compute credits by <a href="https://x.com/except_raised">@except_raised</a>, <a href="https://x.com/twofifteenam">@twofifteenam</a> and <a href="https://x.com/modal_labs">@modal_labs</a></p>
<h2>code</h2>
<p>everything is open sourced and available on <a href="https://github.com/tokenbender/avataRL">github</a>.</p>
<h2>references</h2>
<p>[1] Dong, Q., Dong, L., Tang, Y., Ye, T., Sun, Y., Sui, Z., &amp; Wei, F. (2025). Reinforcement Pre-Training. arXiv:2506.08007.</p>
<p>[2] Hong, J., Dragan, A., &amp; Levine, S. (2024). Q-SFT: Q-Learning for Language Models via Supervised Fine-Tuning. arXiv:2411.05193.</p>
<p>[3] Norouzi, M., Bengio, S., Chen, Z., Jaitly, N., Schuster, M., Wu, Y., &amp; Schuurmans, D. (2016). Reward Augmented Maximum Likelihood for Neural Structured Prediction. NeurIPS 2016.</p>
<p>[4] Shen, S., Cheng, Y., He, Z., He, W., Wu, H., Sun, M., &amp; Liu, Y. (2016). Minimum Risk Training for Neural Machine Translation. Proceedings of ACL 2016.</p>
<p>[5] Ranzato, M. A., Chopra, M., Auli, M., &amp; Zaremba, W. (2016). Sequence Level Training with Recurrent Neural Networks (MIXER). ICLR 2016.</p>
<p>[6] Bahdanau, D., Brakel, P., Xu, K., Goyal, A., Lowe, J., Pineau, J., Courville, A., &amp; Bengio, Y. (2017). An Actor–Critic Algorithm for Sequence Prediction. ICLR 2017.</p>
<p>[7] Peters, J., &amp; Schaal, S. (2007). Reinforcement Learning by Reward-Weighted Regression for Operational Space Control. ICML 2007.</p>
<p>[8] Agarwal, R., Schwarzer, M., Castro, P. S., Courville, A., &amp; Bellemare, M. G. (2022). Reincarnating Reinforcement Learning: Reusing Prior Computation to Accelerate Progress. NeurIPS 2022. arXiv:2206.01626.</p>
<p>[9] Furlanello, T., Lipton, Z., Tschannen, M., Itti, L., &amp; Anandkumar, A. (2018). Born Again Neural Networks. Proceedings of ICML 2018, PMLR 80:1607-1616. arXiv:1805.04770.</p>

        </article>
    </main>

    <footer>
        <p>for updates and random thoughts, follow <a href="https://x.com/tokenbender" target="_blank" rel="noopener">@tokenbender</a>.</p>
    </footer>

    <script>(function () {
    const storageKey = 'tokenbender-theme';
    const root = document.documentElement;
    const toggle = document.querySelector('[data-theme-toggle]');

    const getTheme = () => root.getAttribute('data-theme') === 'light' ? 'light' : 'dark';

    const renderToggle = (activeTheme) => {
        if (!toggle) {
            return;
        }

        const targetTheme = activeTheme === 'light' ? 'dark' : 'light';
        toggle.textContent = targetTheme;
        toggle.setAttribute('aria-label', `switch to ${targetTheme} theme`);
        toggle.setAttribute('aria-pressed', activeTheme === 'light' ? 'true' : 'false');
    };

    const setTheme = (theme, persist) => {
        root.setAttribute('data-theme', theme);
        renderToggle(theme);
        if (persist) {
            try {
                window.localStorage.setItem(storageKey, theme);
            } catch (error) {}
        }
    };

    setTheme(getTheme(), false);

    if (toggle) {
        toggle.addEventListener('click', () => {
            const nextTheme = getTheme() === 'light' ? 'dark' : 'light';
            setTheme(nextTheme, true);
        });
    }

    if (window.matchMedia) {
        const media = window.matchMedia('(prefers-color-scheme: light)');
        const onChange = (event) => {
            let storedTheme = null;
            try {
                storedTheme = window.localStorage.getItem(storageKey);
            } catch (error) {}

            if (storedTheme === 'light' || storedTheme === 'dark') {
                return;
            }

            setTheme(event.matches ? 'light' : 'dark', false);
        };

        if (typeof media.addEventListener === 'function') {
            media.addEventListener('change', onChange);
        } else if (typeof media.addListener === "function") {
            media.addListener(onChange);
        }
    }
})();</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/contrib/auto-render.min.js"></script>
    <script>
        if (window.renderMathInElement) {
            window.renderMathInElement(document.getElementById('post-content'), {
                delimiters: [
                    { left: '$$', right: '$$', display: true },
                    { left: '$', right: '$', display: false },
                    { left: '\\(', right: '\\)', display: false },
                    { left: '\\[', right: '\\]', display: true }
                ],
                throwOnError: false,
                trust: false
            });
        }

        if (window.Prism) {
            window.Prism.highlightAll();
        }
    </script>
</body>
</html>
